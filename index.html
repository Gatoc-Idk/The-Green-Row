<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Step Sequencer with Tempo & Duration</title>
  <style>
    body { font-family: sans-serif; background: #222; color: #eee; display: flex; flex-direction: column; align-items: center; padding: 20px; }
    .grid { display: grid; grid-template-columns: repeat(16, 30px); grid-gap: 5px; margin-bottom: 20px; }
    .pad { width: 30px; height: 30px; background: #444; border-radius: 4px; cursor: pointer; transition: background 0.2s; }
    .pad.active { background: #0f0; }
    button, input[type=range] { padding: 10px 20px; font-size: 16px; margin: 0 10px 10px 10px; cursor: pointer; }
    .controls { margin-bottom: 20px; display: flex; align-items: center; flex-wrap: wrap; gap: 10px; }
    label { font-size: 16px; }
  </style>
</head>
<body>

  <h1>The Green Row</h1>
  <div class="controls">
    <button id="playBtn">Play</button>
    <button id="downloadBtn">Download</button>
    <label for="tempoSlider">Tempo: <span id="tempoVal">120</span> BPM</label>
    <input type="range" id="tempoSlider" min="20" max="300" value="120" />
    <button id="durationBtn">Duration: 1 measure</button>
  </div>
  <div id="padGrid" class="grid"></div>

  <script>
    let bpm = 120;
    const steps = 16;
    const rows = 8;
    let durationMeasures = 1;
    let isPlaying = false;
    let playCtx, scheduledNodes = [];

    // build pad grid
    const padGridElem = document.getElementById("padGrid");
    const padGrid = [];
    for (let r = 0; r < rows; r++) {
      const rowPads = [];
      for (let s = 0; s < steps; s++) {
        const pad = document.createElement("div");
        pad.classList.add("pad");
        pad.addEventListener("click", () => pad.classList.toggle("active"));
        padGridElem.appendChild(pad);
        rowPads.push(pad);
      }
      padGrid.push(rowPads);
    }

    // play button toggle
    document.getElementById("playBtn").addEventListener("click", () => {
      if (!isPlaying) {
        isPlaying = true;
        document.getElementById("playBtn").textContent = "Stop";
        playTrack();
      } else {
        stopTrack();
      }
    });

    // download button
    document.getElementById("downloadBtn").addEventListener("click", downloadTrack);

    // tempo slider update
    const tempoSlider = document.getElementById("tempoSlider");
    const tempoVal = document.getElementById("tempoVal");
    tempoSlider.addEventListener("input", () => {
      bpm = +tempoSlider.value;
      tempoVal.textContent = bpm;
    });

    // duration button cycles between 1, 2, 4 measures
    const durationBtn = document.getElementById("durationBtn");
    durationBtn.addEventListener("click", () => {
      if (durationMeasures === 1) durationMeasures = 2;
      else if (durationMeasures === 2) durationMeasures = 4;
      else durationMeasures = 1;
      durationBtn.textContent = `Duration: ${durationMeasures} measure${durationMeasures > 1 ? "s" : ""}`;
    });

    function playTrack() {
      playCtx = new (window.AudioContext || window.webkitAudioContext)();
      const playMasterGain = playCtx.createGain();
      playMasterGain.gain.value = 0.8;
      playMasterGain.connect(playCtx.destination);

      const measureDuration = (60 / bpm) * 4;
      const totalDuration = measureDuration * durationMeasures;
      const startTime = playCtx.currentTime;

      for (let measure = 0; measure < durationMeasures; measure++) {
        for (let step = 0; step < steps; step++) {
          const time = startTime + measure * measureDuration + step * (60 / bpm) / 4;
          for (let row = 0; row < rows; row++) {
            if (padGrid[row][step].classList.contains("active")) {
              scheduledNodes.push(playOfflineSound(playCtx, row, time, playMasterGain, true));
            }
          }
        }
      }

      // auto-stop after totalDuration
      setTimeout(stopTrack, totalDuration * 1000 + 100);
    }

    function stopTrack() {
      if (!playCtx) return;
      scheduledNodes.forEach(n => {
        try { n.stop(); } catch {}
      });
      scheduledNodes = [];
      playCtx.close();
      playCtx = null;
      isPlaying = false;
      document.getElementById("playBtn").textContent = "Play";
    }

    // offline download
    function downloadTrack() {
      const duration = (60 / bpm) * 4 * durationMeasures;
      const sampleRate = 44100;
      const offlineCtx = new OfflineAudioContext(1, sampleRate * duration, sampleRate);
      const masterGain = offlineCtx.createGain();
      masterGain.gain.setValueAtTime(0.8, 0);
      masterGain.connect(offlineCtx.destination);

      for (let measure = 0; measure < durationMeasures; measure++) {
        for (let step = 0; step < steps; step++) {
          const time = measure * (60 / bpm) * 4 + step * (60 / bpm) / 4;
          for (let row = 0; row < rows; row++) {
            if (padGrid[row][step].classList.contains("active")) {
              playOfflineSound(offlineCtx, row, time, masterGain);
            }
          }
        }
      }

      offlineCtx.startRendering().then(renderedBuffer => {
        const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
        const url = URL.createObjectURL(wavBlob);
        const a = document.createElement("a");
        a.href = url; a.download = "music.wav"; a.click();
        URL.revokeObjectURL(url);
      });
    }

    // playOfflineSound for both real time and offline
    function playOfflineSound(ctx, index, when, destination, live=false) {
      destination = destination || ctx.destination;
      let osc, gainNode, src;

      switch (index) {
        case 0:
          osc = ctx.createOscillator(); gainNode = ctx.createGain();
          osc.type = "sine";
          osc.frequency.setValueAtTime(150, when);
          osc.frequency.exponentialRampToValueAtTime(0.001, when + 0.5);
          gainNode.gain.setValueAtTime(1, when);
          gainNode.gain.exponentialRampToValueAtTime(0.001, when + 0.5);
          break;
        case 1:
          const buf = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
          src = ctx.createBufferSource();
          src.buffer = buf;
          gainNode = ctx.createGain();
          gainNode.gain.setValueAtTime(1, when);
          gainNode.gain.exponentialRampToValueAtTime(0.01, when + 0.2);
          src.connect(gainNode).connect(destination);
          src.start(when);
          if (live) scheduledNodes.push(src);
          return src;
        case 2:
          osc = ctx.createOscillator(); gainNode = ctx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(8000, when);
          gainNode.gain.setValueAtTime(0.2, when);
          gainNode.gain.exponentialRampToValueAtTime(0.001, when + 0.05);
          break;
        case 3:
          osc = ctx.createOscillator(); gainNode = ctx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(600, when);
          gainNode.gain.setValueAtTime(0.3, when);
          gainNode.gain.exponentialRampToValueAtTime(0.001, when + 0.2);
          break;
        case 4:
          osc = ctx.createOscillator(); gainNode = ctx.createGain();
          osc.type = "sine";
          osc.frequency.setValueAtTime(90, when);
          gainNode.gain.setValueAtTime(0.4, when);
          gainNode.gain.exponentialRampToValueAtTime(0.001, when + 0.6);
          break;
        case 5:
          osc = ctx.createOscillator(); gainNode = ctx.createGain();
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(400 + Math.random()*200, when);
          gainNode.gain.setValueAtTime(0.2, when);
          gainNode.gain.exponentialRampToValueAtTime(0.001, when + 0.1);
          break;
        case 6:
          const cb = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
          const cd = cb.getChannelData(0);
          for (let i = 0; i < cd.length; i++) cd[i] = Math.random()*2 - 1;
          src = ctx.createBufferSource();
          src.buffer = cb;
          gainNode = ctx.createGain();
          gainNode.gain.setValueAtTime(1, when);
          gainNode.gain.exponentialRampToValueAtTime(0.01, when + 0.1);
          src.connect(gainNode).connect(destination);
          src.start(when);
          if (live) scheduledNodes.push(src);
          return src;
        case 7:
          osc = ctx.createOscillator(); gainNode = ctx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(880, when);
          gainNode.gain.setValueAtTime(0.4, when);
          gainNode.gain.exponentialRampToValueAtTime(0.001, when + 0.6);
          break;
      }

      if (osc) {
        osc.connect(gainNode).connect(destination);
        osc.start(when);
        osc.stop(when + (gainNode.gain.value === 1 ? 0.5 : (gainNode.gain.value === 0.2 ? 0.05 : 0.2)));
        if (live) scheduledNodes.push(osc);
        return osc;
  }
}

// helper to convert AudioBuffer to WAV Blob
function bufferToWave(abuffer, len) {
  let numOfChan = abuffer.numberOfChannels,
      length = len * numOfChan * 2 + 44,
      buffer = new ArrayBuffer(length),
      view = new DataView(buffer),
      channels = [], i, sample,
      offset = 0,
      pos = 0;

  function setUint16(data) {
    view.setUint16(pos, data, true);
    pos += 2;
  }
  function setUint32(data) {
    view.setUint32(pos, data, true);
    pos += 4;
  }

  // RIFF chunk descriptor
  writeString("RIFF"); setUint32(length - 8); writeString("WAVE");
  // fmt subchunk
  writeString("fmt "); setUint32(16); setUint16(1); setUint16(numOfChan);
  setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2); setUint16(16);
  // data subchunk
  writeString("data"); setUint32(length - pos - 4);

  // write interleaved data
  for(i = 0; i < abuffer.numberOfChannels; i++)
    channels.push(abuffer.getChannelData(i));

  while(pos < length) {
    for(i = 0; i < numOfChan; i++) {
      sample = Math.max(-1, Math.min(1, channels[i][offset]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF) | 0;
      view.setInt16(pos, sample, true);
      pos += 2;
    }
    offset++;
  }

  function writeString(s) {
    for(let i=0; i<s.length; i++) {
      view.setUint8(pos, s.charCodeAt(i));
      pos++;
    }
  }

  return new Blob([buffer], {type:"audio/wav"});
}
</script> </body> </html>