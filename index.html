<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Green Row</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: white;
      text-align: center;
    }
    .pad-grid {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin: 20px auto;
    }
    .row {
      display: flex;
      gap: 2px;
      overflow-x: auto;
    }
    .pad {
      width: 20px;
      height: 20px;
      background: #333;
      border: 1px solid #555;
      cursor: pointer;
    }
    .pad.active {
      background: #0f0;
    }
    button, input[type="range"] {
      margin: 10px;
      padding: 5px 10px;
    }
  </style>
</head>
<body>
  <h1>The Green Row</h1>
  <label for="widthSlider">Steps per Row:</label>
  <input type="range" id="widthSlider" min="4" max="100" value="16" />
  <br />
  <button id="play">Play</button>
  <button id="download">Download</button>
  <div class="pad-grid" id="padGrid"></div>

  <script>
    let bpm = 120;
    let steps = 16;
    const rows = 8;
    const padGrid = [];

    const gridContainer = document.getElementById("padGrid");

    function createGrid() {
      gridContainer.innerHTML = "";
      padGrid.length = 0;
      for (let row = 0; row < rows; row++) {
        const rowEl = document.createElement("div");
        rowEl.className = "row";
        padGrid[row] = [];
        for (let step = 0; step < steps; step++) {
          const pad = document.createElement("div");
          pad.className = "pad";
          pad.addEventListener("click", () => {
            pad.classList.toggle("active");
          });
          rowEl.appendChild(pad);
          padGrid[row].push(pad);
        }
        gridContainer.appendChild(rowEl);
      }
    }

    document.getElementById("widthSlider").addEventListener("input", e => {
      steps = parseInt(e.target.value);
      createGrid();
    });

    document.getElementById("play").addEventListener("click", () => {
      const ctx = new AudioContext();
      const startTime = ctx.currentTime;
      for (let step = 0; step < steps; step++) {
        const time = startTime + step * (60 / bpm) / 4;
        for (let row = 0; row < rows; row++) {
          if (padGrid[row][step].classList.contains("active")) {
            playSound(ctx, row, time);
          }
        }
      }
    });

    document.getElementById("download").addEventListener("click", () => {
      const duration = (60 / bpm) * 4;
      const sampleRate = 44100;
      const offlineCtx = new OfflineAudioContext(1, sampleRate * duration, sampleRate);
      for (let step = 0; step < steps; step++) {
        const time = step * (60 / bpm) / 4;
        for (let row = 0; row < rows; row++) {
          if (padGrid[row][step].classList.contains("active")) {
            playOfflineSound(offlineCtx, row, time);
          }
        }
      }

      offlineCtx.startRendering().then(renderedBuffer => {
        const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
        const url = URL.createObjectURL(wavBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "music.wav";
        a.click();
        URL.revokeObjectURL(url);
      });
    });

    function playSound(ctx, index, when) {
      playOfflineSound(ctx, index, when);
    }

    function playOfflineSound(ctx, index, when) {
      switch (index) {
        case 0:
          let kick = ctx.createOscillator();
          let kickGain = ctx.createGain();
          kick.type = "sine";
          kick.frequency.setValueAtTime(150, when);
          kick.frequency.exponentialRampToValueAtTime(0.001, when + 0.5);
          kickGain.gain.setValueAtTime(1, when);
          kickGain.gain.exponentialRampToValueAtTime(0.001, when + 0.5);
          kick.connect(kickGain).connect(ctx.destination);
          kick.start(when);
          kick.stop(when + 0.5);
          break;
        case 1:
          const snareBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
          const snareData = snareBuffer.getChannelData(0);
          for (let i = 0; i < snareData.length; i++) snareData[i] = Math.random() * 2 - 1;
          const snare = ctx.createBufferSource();
          snare.buffer = snareBuffer;
          const snareGain = ctx.createGain();
          snareGain.gain.setValueAtTime(1, when);
          snareGain.gain.exponentialRampToValueAtTime(0.01, when + 0.2);
          snare.connect(snareGain).connect(ctx.destination);
          snare.start(when);
          break;
        case 2:
          const hat = ctx.createOscillator();
          const hatGain = ctx.createGain();
          hat.type = 'square';
          hat.frequency.setValueAtTime(8000, when);
          hatGain.gain.setValueAtTime(0.2, when);
          hatGain.gain.exponentialRampToValueAtTime(0.001, when + 0.05);
          hat.connect(hatGain).connect(ctx.destination);
          hat.start(when);
          hat.stop(when + 0.05);
          break;
        case 3:
          const beep = ctx.createOscillator();
          const beepGain = ctx.createGain();
          beep.type = 'square';
          beep.frequency.setValueAtTime(600, when);
          beepGain.gain.setValueAtTime(0.3, when);
          beepGain.gain.exponentialRampToValueAtTime(0.001, when + 0.2);
          beep.connect(beepGain).connect(ctx.destination);
          beep.start(when);
          beep.stop(when + 0.2);
          break;
        case 4:
          const sub = ctx.createOscillator();
          const subGain = ctx.createGain();
          sub.type = "sine";
          sub.frequency.setValueAtTime(90, when);
          subGain.gain.setValueAtTime(0.4, when);
          subGain.gain.exponentialRampToValueAtTime(0.001, when + 0.6);
          sub.connect(subGain).connect(ctx.destination);
          sub.start(when);
          sub.stop(when + 0.6);
          break;
        case 5:
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(400 + Math.random() * 200, when);
          gain.gain.setValueAtTime(0.2, when);
          gain.gain.exponentialRampToValueAtTime(0.001, when + 0.1);
          osc.connect(gain).connect(ctx.destination);
          osc.start(when);
          osc.stop(when + 0.1);
          break;
        case 6:
          const clapBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
          const clapData = clapBuffer.getChannelData(0);
          for (let i = 0; i < clapData.length; i++) clapData[i] = Math.random() * 2 - 1;
          const clap = ctx.createBufferSource();
          clap.buffer = clapBuffer;
          const clapGain = ctx.createGain();
          clapGain.gain.setValueAtTime(1, when);
          clapGain.gain.exponentialRampToValueAtTime(0.01, when + 0.1);
          clap.connect(clapGain).connect(ctx.destination);
          clap.start(when);
          break;
        case 7:
          const ping = ctx.createOscillator();
          const pingGain = ctx.createGain();
          ping.type = "triangle";
          ping.frequency.setValueAtTime(880, when);
          pingGain.gain.setValueAtTime(0.4, when);
          pingGain.gain.exponentialRampToValueAtTime(0.001, when + 0.6);
          ping.connect(pingGain).connect(ctx.destination);
          ping.start(when);
          ping.stop(when + 0.6);
          break;
      }
    }

    function bufferToWave(buffer, length) {
      const numOfChan = buffer.numberOfChannels;
      const lengthInSamples = length * numOfChan * 2;
      const bufferArray = new ArrayBuffer(44 + lengthInSamples);
      const view = new DataView(bufferArray);
      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
      }
      const channels = [];
      for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));
      let offset = 0;
      writeString(view, offset, 'RIFF'); offset += 4;
      view.setUint32(offset, 36 + lengthInSamples, true); offset += 4;
      writeString(view, offset, 'WAVE'); offset += 4;
      writeString(view, offset, 'fmt '); offset += 4;
      view.setUint32(offset, 16, true); offset += 4;
      view.setUint16(offset, 1, true); offset += 2;
      view.setUint16(offset, numOfChan, true); offset += 2;
      view.setUint32(offset, buffer.sampleRate, true); offset += 4;
      view.setUint32(offset, buffer.sampleRate * numOfChan * 2, true); offset += 4;
      view.setUint16(offset, numOfChan * 2, true); offset += 2;
      view.setUint16(offset, 16, true); offset += 2;
      writeString(view, offset, 'data'); offset += 4;
      view.setUint32(offset, lengthInSamples, true); offset += 4;
      for (let i = 0; i < length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          let sample = Math.max(-1, Math.min(1, channels[channel][i]));
          sample = (sample * 32767) | 0;
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    }

    // Initialize grid
    createGrid();
  </script>
</body>
</html>
