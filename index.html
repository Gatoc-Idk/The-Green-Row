<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Green Row</title>
  <style>
    body { font-family: sans-serif; background: #222; color: #eee; padding: 20px; display: flex; flex-direction: column; align-items: center; }
    .controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
    button, input[type=range] { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    label { font-size: 16px; }
    .row-container { display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; }
    .row { display: flex; gap: 5px; margin-bottom: 5px; }
    .pad { width: 30px; height: 30px; background: #444; border-radius: 4px; cursor: pointer; transition: background 0.2s; }
    .pad.active { background: #0f0; }
  </style>
</head>
<body>

  <h1>The Green Row</h1>
  <div class="controls">
    <button id="playBtn">Play</button>
    <button id="downloadBtn">Download</button>
    <label for="tempoSlider">Tempo: <span id="tempoVal">120</span> BPM</label>
    <input type="range" id="tempoSlider" min="20" max="300" value="120" />
    <label for="widthSlider">Width: <span id="widthVal">16</span> Steps</label>
    <input type="range" id="widthSlider" min="4" max="32" value="16" />
  </div>

  <div id="sequencer"></div>

  <script>
    const numRows = 8;
    let bpm = 120;
    let stepCount = 16;
    let isPlaying = false;
    let playCtx, scheduledNodes = [];
    const padGrid = [];

    const sequencer = document.getElementById("sequencer");
    const tempoSlider = document.getElementById("tempoSlider");
    const tempoVal = document.getElementById("tempoVal");
    const widthSlider = document.getElementById("widthSlider");
    const widthVal = document.getElementById("widthVal");

    function createSequencerGrid() {
      sequencer.innerHTML = "";
      padGrid.length = 0;

      for (let row = 0; row < numRows; row++) {
        const rowContainer = document.createElement("div");
        rowContainer.className = "row-container";

        const rowElem = document.createElement("div");
        rowElem.className = "row";

        const padRow = [];
        for (let step = 0; step < stepCount; step++) {
          const pad = createPad();
          rowElem.appendChild(pad);
          padRow.push(pad);
        }

        padGrid.push(padRow);
        rowContainer.appendChild(rowElem);
        sequencer.appendChild(rowContainer);
      }
    }

    function updateRowLengths(newLength) {
      stepCount = newLength;
      widthVal.textContent = newLength;
      for (let row = 0; row < numRows; row++) {
        const padRow = padGrid[row];
        const rowElem = sequencer.children[row].querySelector(".row");

        while (padRow.length > newLength) {
          padRow.pop();
          rowElem.removeChild(rowElem.lastChild);
        }

        while (padRow.length < newLength) {
          const pad = createPad();
          rowElem.appendChild(pad);
          padRow.push(pad);
        }
      }
    }

    function createPad() {
      const pad = document.createElement("div");
      pad.className = "pad";
      pad.addEventListener("click", () => pad.classList.toggle("active"));
      return pad;
    }

    tempoSlider.addEventListener("input", () => {
      bpm = +tempoSlider.value;
      tempoVal.textContent = bpm;
    });

    widthSlider.addEventListener("input", () => {
      updateRowLengths(+widthSlider.value);
    });

    document.getElementById("playBtn").addEventListener("click", () => {
      if (!isPlaying) {
        isPlaying = true;
        document.getElementById("playBtn").textContent = "Stop";
        playTrack();
      } else {
        stopTrack();
      }
    });

    function playTrack() {
      playCtx = new (window.AudioContext || window.webkitAudioContext)();
      const masterGain = playCtx.createGain();
      masterGain.gain.value = 0.8;
      masterGain.connect(playCtx.destination);

      const stepDuration = (60 / bpm) / 4;
      const startTime = playCtx.currentTime;

      for (let step = 0; step < stepCount; step++) {
        const time = startTime + step * stepDuration;
        for (let row = 0; row < numRows; row++) {
          if (padGrid[row][step]?.classList.contains("active")) {
            scheduledNodes.push(playOfflineSound(playCtx, row, time, masterGain, true));
          }
        }
      }

      setTimeout(stopTrack, stepCount * stepDuration * 1000 + 100);
    }

    function stopTrack() {
      if (!playCtx) return;
      scheduledNodes.forEach(n => { try { n.stop(); } catch {} });
      scheduledNodes = [];
      playCtx.close();
      playCtx = null;
      isPlaying = false;
      document.getElementById("playBtn").textContent = "Play";
    }

    document.getElementById("downloadBtn").addEventListener("click", downloadTrack);

    function downloadTrack() {
      const duration = (60 / bpm) * (stepCount / 4);
      const sampleRate = 44100;
      const offlineCtx = new OfflineAudioContext(1, sampleRate * duration, sampleRate);

      for (let step = 0; step < stepCount; step++) {
        const time = step * (60 / bpm) / 4;
        for (let row = 0; row < numRows; row++) {
          if (padGrid[row][step]?.classList.contains("active")) {
            playOfflineSound(offlineCtx, row, time);
          }
        }
      }

      offlineCtx.startRendering().then(renderedBuffer => {
        const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
        const url = URL.createObjectURL(wavBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "music.wav";
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    function playOfflineSound(ctx, index, when, destination, live = false) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.4, when);
      gain.gain.exponentialRampToValueAtTime(0.001, when + 0.3);
      osc.type = ["sine", "square", "sawtooth", "triangle"][index % 4];
      osc.frequency.setValueAtTime(200 + index * 50, when);
      osc.connect(gain).connect(destination || ctx.destination);
      osc.start(when);
      osc.stop(when + 0.3);
      if (live) return osc;
    }

    function bufferToWave(buffer, length) {
      const numOfChan = buffer.numberOfChannels;
      const lengthInSamples = length * numOfChan * 2;
      const bufferArray = new ArrayBuffer(44 + lengthInSamples);
      const view = new DataView(bufferArray);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
      }

      const channels = [];
      for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));

      let offset = 0;
      writeString(view, offset, 'RIFF'); offset += 4;
      view.setUint32(offset, 36 + lengthInSamples, true); offset += 4;
      writeString(view, offset, 'WAVE'); offset += 4;
      writeString(view, offset, 'fmt '); offset += 4;
      view.setUint32(offset, 16, true); offset += 4;
      view.setUint16(offset, 1, true); offset += 2;
      view.setUint16(offset, numOfChan, true); offset += 2;
      view.setUint32(offset, buffer.sampleRate, true); offset += 4;
      view.setUint32(offset, buffer.sampleRate * numOfChan * 2, true); offset += 4;
      view.setUint16(offset, numOfChan * 2, true); offset += 2;
      view.setUint16(offset, 16, true); offset += 2;
      writeString(view, offset, 'data'); offset += 4;
      view.setUint32(offset, lengthInSamples, true); offset += 4;

      for (let i = 0; i < length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          let sample = Math.max(-1, Math.min(1, channels[channel][i]));
          sample = (sample * 32767) | 0;
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    createSequencerGrid(); // Initial load
  </script>
</body>
</html>
